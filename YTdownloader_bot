import os
import asyncio
import subprocess
from aiogram import Bot, Dispatcher, types, F, Router
from aiogram.types import InputFile, InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.filters import Command
from yt_dlp import YoutubeDL
import re

# --- –ù–∞—Å—Ç—Ä–æ–π–∫–∏ ---
TOKEN = "TG_TOKEN"
TEMP_DIR = "downloads"
os.makedirs(TEMP_DIR, exist_ok=True)

bot = Bot(token=TOKEN)
dp = Dispatcher()
router = Router()

# --- –ü—Ä–æ–≤–µ—Ä–∫–∞ FFmpeg ---
def check_ffmpeg():
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å FFmpeg"""
    try:
        subprocess.run(['ffmpeg', '-version'], capture_output=True, check=True)
        return True
    except (subprocess.CalledProcessError, FileNotFoundError):
        return False

has_ffmpeg = check_ffmpeg()
print(f"FFmpeg –¥–æ—Å—Ç—É–ø–µ–Ω: {has_ffmpeg}")

# --- –û–ø—Ü–∏–∏ yt-dlp –¥–ª—è Ubuntu —Å FFmpeg ---
def get_ydl_opts(audio=False):
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ–ø—Ü–∏–∏ –¥–ª—è yt-dlp"""

    base_opts = {
        "outtmpl": f"{TEMP_DIR}/%(title)s.%(ext)s",
        "noplaylist": True,
        "quiet": True,
        "ffmpeg_location": "/usr/bin/ffmpeg",
    }

    if audio:
        return {
            **base_opts,
            "format": "bestaudio/best",
            "postprocessors": [{
                "key": "FFmpegExtractAudio",
                "preferredcodec": "mp3",
                "preferredquality": "192"
            }],
        }
    else:
        return {
            **base_opts,
            "format": "bestvideo[height<=1080]+bestaudio/best[height<=1080]/best",
            "merge_output_format": "mp4",
        }

def get_ydl_opts_safe(audio=False):
    """–ë–æ–ª–µ–µ –±–µ–∑–æ–ø–∞—Å–Ω—ã–µ –æ–ø—Ü–∏–∏"""

    base_opts = {
        "outtmpl": f"{TEMP_DIR}/%(title)s.%(ext)s",
        "noplaylist": True,
        "quiet": True,
        "ffmpeg_location": "/usr/bin/ffmpeg",
        "ignoreerrors": True,
    }

    if audio:
        return {
            **base_opts,
            "format": "bestaudio",
        }
    else:
        return {
            **base_opts,
            "format": "best[ext=mp4]/best[height<=720]/best",
        }

user_links = {}

def is_youtube_url(url: str) -> bool:
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å—Ç—Ä–æ–∫–∞ YouTube —Å—Å—ã–ª–∫–æ–π"""
    youtube_regex = (
        r'(https?://)?(www\.)?'
        r'(youtube|youtu|youtube-nocookie)\.(com|be)/'
        r'(watch\?v=|embed/|v/|.+\?v=)?([^&=%\?]{11})')
    return re.match(youtube_regex, url) is not None

async def download_video(url: str, audio: bool = False) -> str:
    """–°–∫–∞—á–∏–≤–∞–µ—Ç –≤–∏–¥–µ–æ/–∞—É–¥–∏–æ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø—É—Ç—å –∫ —Ñ–∞–π–ª—É"""

    opts_list = [get_ydl_opts(audio), get_ydl_opts_safe(audio)]
    last_error = None

    for i, opts in enumerate(opts_list):
        try:
            print(f"–ü–æ–ø—ã—Ç–∫–∞ {i+1} —Å –æ–ø—Ü–∏—è–º–∏: {opts.get('format', 'default')}")

            def _download():
                with YoutubeDL(opts) as ydl:
                    def progress_hook(d):
                        if d['status'] == 'downloading':
                            print(f"–°–∫–∞—á–∏–≤–∞–Ω–∏–µ: {d.get('_percent_str', 'N/A')}")
                        elif d['status'] == 'finished':
                            print("–°–∫–∞—á–∏–≤–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ")

                    ydl.add_progress_hook(progress_hook)

                    info = ydl.extract_info(url, download=True)
                    filename = ydl.prepare_filename(info)

                    if audio:
                        filename = os.path.splitext(filename)[0] + ".mp3"

                    print(f"–§–∞–π–ª –≥–æ—Ç–æ–≤: {filename}")
                    return filename

            filename = await asyncio.to_thread(_download)

            if os.path.exists(filename) and os.path.getsize(filename) > 0:
                return filename
            else:
                raise Exception("–§–∞–π–ª –Ω–µ –±—ã–ª —Å–æ–∑–¥–∞–Ω")

        except Exception as e:
            last_error = e
            print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ø—ã—Ç–∫–µ {i+1}: {e}")
            continue

    raise Exception(f"–í—Å–µ –ø–æ–ø—ã—Ç–∫–∏ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è –ø—Ä–æ–≤–∞–ª–∏–ª–∏—Å—å: {last_error}")
# --- –•—ç–Ω–¥–ª–µ—Ä—ã ---
@router.message(Command("start"))
async def start(message: types.Message):
    await message.answer(
        "–ü—Ä–∏–≤–µ—Ç! –Ø YouTube downloader –±–æ—Ç. üé•üéµ\n\n"
        "–û—Ç–ø—Ä–∞–≤—å –º–Ω–µ —Å—Å—ã–ª–∫—É –Ω–∞ YouTube –≤–∏–¥–µ–æ, –∏ —è —Å–∫–∞—á–∞—é –µ–≥–æ –¥–ª—è —Ç–µ–±—è.\n"
        f"–°—Ç–∞—Ç—É—Å FFmpeg: {'‚úÖ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω' if has_ffmpeg else '‚ùå –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω'}"
    )

@router.message(F.text)
async def handle_link(message: types.Message):
    url = message.text.strip()

    if not is_youtube_url(url):
        await message.answer("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—É—é —Å—Å—ã–ª–∫—É –Ω–∞ YouTube –≤–∏–¥–µ–æ.")
        return

    if not url.startswith(('http://', 'https://')):
        url = 'https://' + url

    user_links[message.from_user.id] = url

    kb = InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(text="üé• –í–∏–¥–µ–æ (MP4)", callback_data="format_video"),
            InlineKeyboardButton(text="üéµ –ê—É–¥–∏–æ (MP3)", callback_data="format_audio")
        ]
    ])

    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–æ—Ä–º–∞—Ç –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è:", reply_markup=kb)

@router.callback_query(F.data.in_(["format_video", "format_audio"]))
async def handle_format(callback: types.CallbackQuery):
    await callback.answer()
    user_id = callback.from_user.id

    if user_id not in user_links:
        await callback.message.answer("‚ùå –°—Å—ã–ª–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –µ—ë —Å–Ω–æ–≤–∞.")
        return

    url = user_links[user_id]
    audio = callback.data == "format_audio"
    format_type = "–∞—É–¥–∏–æ" if audio else "–≤–∏–¥–µ–æ"

    filename = None

    try:
        await callback.message.delete()
        status_msg = await callback.message.answer(f"‚è≥ –°–∫–∞—á–∏–≤–∞—é {format_type}...")

        filename = await download_video(url, audio)

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞
        file_size = os.path.getsize(filename)
        max_size = 50 * 1024 * 1024  # 50MB

        if file_size > max_size:
            await status_msg.edit_text(
                f"‚ùå –§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π ({file_size // (1024*1024)}MB). "
                f"–ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä: 50MB"
            )
            if filename and os.path.exists(filename):
                os.remove(filename)
            return

        await status_msg.edit_text("üì§ –û—Ç–ø—Ä–∞–≤–ª—è—é —Ñ–∞–π–ª...")

        # –ü–†–ê–í–ò–õ–¨–ù–û–ï –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ InputFile –≤ aiogram 3.x
        # –ü—Ä–æ—Å—Ç–æ –ø–µ—Ä–µ–¥–∞–µ–º –ø—É—Ç—å –∫ —Ñ–∞–π–ª—É –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º –º–µ–Ω–µ–¥–∂–µ—Ä –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
        if audio:
            # –î–ª—è –∞—É–¥–∏–æ - –∏—Å–ø–æ–ª—å–∑—É–µ–º –º–µ–Ω–µ–¥–∂–µ—Ä –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
            with open(filename, 'rb') as audio_file:
                await callback.message.answer_audio(
                    audio=types.BufferedInputFile(
                        audio_file.read(),
                        filename=os.path.basename(filename)
                    ),
                    caption="üéµ –ê—É–¥–∏–æ –≥–æ—Ç–æ–≤–æ!"
                )
        else:
            # –î–ª—è –≤–∏–¥–µ–æ - –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä—è–º–æ–π –ø—É—Ç—å (InputFile —Å–∞–º –æ–±—Ä–∞–±–æ—Ç–∞–µ—Ç)
            await callback.message.answer_video(
                video=types.FSInputFile(filename),
                caption="üé• –í–∏–¥–µ–æ –≥–æ—Ç–æ–≤–æ!"
            )

        await status_msg.delete()

    except Exception as e:
        error_msg = f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–∫–∞—á–∏–≤–∞–Ω–∏–∏: {str(e)}"
        print(f"–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: {e}")

        if "aborting due to --abort-on-error" in str(e).lower():
            error_msg = (
                "‚ùå –û—à–∏–±–∫–∞ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏—è –ø–æ—Ç–æ–∫–æ–≤. \n\n"
                "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –¥—Ä—É–≥–æ–π —Ñ–æ—Ä–º–∞—Ç –∏–ª–∏ —Å—Å—ã–ª–∫—É."
            )

        try:
            await status_msg.edit_text(error_msg)
        except:
            await callback.message.answer(error_msg)
    finally:
        user_links.pop(user_id, None)
        if filename and os.path.exists(filename):
            try:
                os.remove(filename)
            except Exception as e:
                print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Ñ–∞–π–ª–∞: {e}")

dp.include_router(router)

async def main():
    await dp.start_polling(bot)

if __name__ == "__main__":
    print("–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω...")
    print(f"FFmpeg –¥–æ—Å—Ç—É–ø–µ–Ω: {has_ffmpeg}")
    asyncio.run(main())


